'-fwrapv' is buggy in gcc-4.1.x, consider using '-fno-strict-overflow' instead.

XXX: More clarification are needed for (1) and (2).


(1) About subptr_64() function:
-------------------------------

 Behavior depends on the pointers provenance. In all cases, 
 pointer to integer casts (and vice-versa) depends on the 
 implementation (implementation defined). Pointers should 
 always be converted to uintptr_t or to unsigned long for
 LP64 system.
 
 In case:
	To the same object(+1) or to members of the same object 
	(array, struct, union) the behavior is defined. It should
	be noted that (pointer) arithmetic on uintptr_t is unspecified
	(probably implementation defined)(2). It conerns cm_grow() function.
 else (recalculate_addr() and cm_do_deserialize())
	C11: undefined behaviour (probably implementation defined, 
	     does not clearly specify)
	C2X: Should permit some version of these codes with suitable
	     annotation / no-provenance option proposal.[1]

 Usage of AT&T/UNIX inline assembly could solve this?


(2) About uintptr_t arithmetic:
-------------------------------

 Arithmetic on uintptr_t is unspecified in the ISO C11 standard. 

 2.2.3 Q5. Must provenance information be tracked via casts to 
 integer types and integer arithmetic? [1]
		- C11: the text does not clearly specify. 
		- C2x proposal: yes. 
		- C2x proposal (no-provenance option): no.

 GCC documentation:
	"When casting from pointer to integer and back again, 
	 the resulting pointer must reference the same object 
	 as the original pointer, otherwise the behavior is 
	 undefined."

 It's problematic because gcc introduces a new undefined behavior. 
 In addition, this implies that two implementation defined behavior 
 become undefined together. It's a mistake for me (standard violation?). 
 (Concerning ptr to integer cast and integers arithmetic).
 
 Consider turn off the optimization for this use case? Is it possible? 



ref
---

[1] https://www.cl.cam.ac.uk/~pes20/cerberus/

